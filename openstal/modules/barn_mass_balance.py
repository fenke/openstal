# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/27_stal_massabalans.ipynb.

# %% auto 0
__all__ = ['pco2_category_functions_mapping', 'pco2_category_functions_parameters', 'default_pco2_parameters', 'gas_density',
           'gas_density_from_sensor_measurment', 'PCO2_melkvee', 'PCO2_pinken', 'calculate_temperatuur_correctie',
           'PCO2_temperatuurcorrectie', 'create_pco2_function_mapping_from_parameters', 'PCO2_calculation_from_mapping',
           'find_production_column_names', 'extract_production_column_names', 'find_emission_column_names',
           'extract_emission_column_names', 'resample_data', 'calculate_pco2_production_from_data',
           'calculate_emission_ratio', 'calculate_emission']

# %% ../../nbs/27_stal_massabalans.ipynb 3
import inspect
import numpy as np
import pandas as pd
from scipy.constants import gas_constant

from pandas import DataFrame
from corebridge.aicorebridge import AICoreModule



# %% ../../nbs/27_stal_massabalans.ipynb 5
kelvin_zero = -273.15

# %% ../../nbs/27_stal_massabalans.ipynb 6
MOLECULAR_MASS = dict(
    co2=44.01,
    nh3=17.031,
    ch4=16.043
)

MOLECULAR_NAMES = { 
    k: ([v] if isinstance(v, str) else list(v)) + [k]
    for k, v in dict(
        co2=['carbon_dioxide', 'carbon dioxide', 'kooldioxide', 'co2'],
        nh3=['ammonia', 'nh3', 'ammoniak'],
        ch4=['methane', 'methaan', 'ch4']
    ).items() 
}


# %% ../../nbs/27_stal_massabalans.ipynb 12
def gas_density(
        P:float,        # pressure in Pascal
        T:float,        # temperature in Kelvin
        ppm:float,      # measured parts per million
        molweight:float # molecular weight in grams per mole
    ):
    '''Calculates mass density in grams per cubic metre
    P : pressure in Pa
    T : temperature in degrees Kelvin
    ppm : measured parts per million
    molweight: molecular weight in grams per mole'''

    return (ppm/1000000) * molweight * P / (gas_constant * T)


# %% ../../nbs/27_stal_massabalans.ipynb 16
def gas_density_from_sensor_measurment(
        ppm:float,          # measured parts per million
        molweight:float):   # molecular weight in grams per mole
    '''Calculates mass density in milligrams per cubic metre'''

    return round(0.0409 * ppm * molweight,5)


# %% ../../nbs/27_stal_massabalans.ipynb 20
# =(5.6*(B10^0.75)+22*B7+1.6*(10^-5)*(B14^3))*B3/1000

def PCO2_melkvee(
        aantal,             # number of animals
        melkproductie,      # milk production in kg per animal per day
        drachtdagen,        # days carrying (average)
        gewicht             # average weight of the animals in kg 
    ):
    '''CO2 productie van melkvee per dier per dag
    gewicht: (gemiddelde) gewicht van de dieren
    melkproductie: melkproductie in kg per dier per dag
    drachtdagen: gemiddelde drachttijd (in dagen)
    De defaults zijn voor droogstaande koeien'''
    return aantal * 0.2 * (
        5.6 * np.pow(gewicht, 0.75) +
        22 * melkproductie +
        1.6e-5 * np.pow(drachtdagen, 3.0)
    ) / 1000.0


# %% ../../nbs/27_stal_massabalans.ipynb 24
def PCO2_pinken(
        aantal,             # number of animals
        energievoeding,     # energy feed
        drachtdagen,        # days carrying (average)
        gewicht,            # average weight of the animals in kg 
        gewichtstoename     # average weight gain of the animals in kg per day
    ):
        
    '''CO2 productie van pinken'''
    
    return aantal * 0.2 * (
        7.64 * np.pow(gewicht, 0.69) +
        gewichtstoename * 
            (23.0 / energievoeding - 1.0) * (
                (57.27 + 0.302 * gewicht) / 
                (1 - 0.171 * gewichtstoename) 
            ) +
        1.6e-5 * np.pow(drachtdagen, 3.0)
    ) / 1000.0




# %% ../../nbs/27_stal_massabalans.ipynb 28
def calculate_temperatuur_correctie(temperatuur):
    '''Calculate temperature correction factor for CO2 production'''
    return (1000.0 + 4.0 * (20.0 - temperatuur)) / 1000.0

def PCO2_temperatuurcorrectie(
        pco2,           # calculated CO2 production in cubic meters per hour
        temperatuur     # temperature in the barn in degrees Celsius
    ):
    '''Bereken temperatuur correctie voor de CO2 productie'''
    
    return pco2 * calculate_temperatuur_correctie(temperatuur)


# %% ../../nbs/27_stal_massabalans.ipynb 31
pco2_category_functions_mapping = {
    "melkvee": PCO2_melkvee,
    "droogstaande koeien": PCO2_melkvee,
    "drachtig jongvee": PCO2_pinken,
    "niet drachtig jongvee": PCO2_pinken,
}
pco2_category_functions_parameters = {
    k: dict(inspect.signature(v).parameters)
    for k, v in pco2_category_functions_mapping.items()
}

# %% ../../nbs/27_stal_massabalans.ipynb 34
_default_parameters = [
    dict(
        categorie='melkvee',
        gewicht=650,  # kg
        drachtdagen=160,  # days
    ),
    dict(
        categorie='droogstaande koeien',
        gewicht=650,  # kg
        drachtdagen=220,  # days
        melkproductie=0,  # kg per day
    ),
    dict(
        categorie='drachtig jongvee',
        gewicht=400,  # kg
        drachtdagen=140,  # days
        energievoeding=10.0,  # MJ NEL per kg
        gewichtstoename=0.6,  # kg per day
    ),
    dict(
        categorie='niet drachtig jongvee',
        gewicht=250,  # kg
        drachtdagen=0,  # days
        energievoeding=10.0,  # MJ NEL per kg
        gewichtstoename=0.6,  # kg per day
    ),
]

# %% ../../nbs/27_stal_massabalans.ipynb 36
default_pco2_parameters = {
    kwargs_item.pop('categorie'): kwargs_item.copy()
    for kwargs_item in _default_parameters
}


# %% ../../nbs/27_stal_massabalans.ipynb 38
def create_pco2_function_mapping_from_parameters(pco2_parameters):
    '''Create a mapping of category to PCO2 calculation functions'''

    parameters = default_pco2_parameters.copy()
    parameters.update(pco2_parameters)
    #print(json.dumps(parameters, indent=4))

    return {
        'melkvee': lambda aantal, **kwargs: PCO2_melkvee(
            aantal=aantal,
            melkproductie=kwargs.get('melkproductie', parameters['melkvee']['melkproductie']),  # kg per day
            drachtdagen=kwargs.get('drachtdagen', parameters['melkvee']['drachtdagen']),  # days
            gewicht=kwargs.get('gewicht',  parameters['melkvee']['gewicht'])  # kg
        ),
        'droogstaande koeien': lambda aantal, **kwargs: PCO2_melkvee(
            aantal=aantal,
            melkproductie=kwargs.get('melkproductie', 0),  # kg per day
            drachtdagen=kwargs.get('drachtdagen', parameters['droogstaande koeien']['drachtdagen']),  # days
            gewicht=kwargs.get('gewicht', parameters['droogstaande koeien']['gewicht'])  # kg
        ),
        'drachtig jongvee': lambda aantal, **kwargs: PCO2_pinken(
            aantal=aantal,
            energievoeding=kwargs.get('energievoeding', parameters['drachtig jongvee']['energievoeding']),  # MJ NEL per kg
            drachtdagen=kwargs.get('drachtdagen', parameters['drachtig jongvee']['drachtdagen']),  # days
            gewicht=kwargs.get('gewicht', parameters['drachtig jongvee']['gewicht']),  # kg
            gewichtstoename=kwargs.get('gewichtstoename', parameters['drachtig jongvee']['gewichtstoename'])  # kg per day
        ),
        'niet drachtig jongvee': lambda aantal, **kwargs: PCO2_pinken(
            aantal=aantal,
            energievoeding=kwargs.get('energievoeding', parameters['niet drachtig jongvee']['energievoeding']),  # MJ NEL per kg
            drachtdagen=kwargs.get('drachtdagen', parameters['niet drachtig jongvee']['drachtdagen']),  # days
            gewicht=kwargs.get('gewicht', parameters['niet drachtig jongvee']['gewicht']),  # kg
            gewichtstoename=kwargs.get('gewichtstoename', parameters['niet drachtig jongvee']['gewichtstoename'])  # kg per day
        )
    }

# %% ../../nbs/27_stal_massabalans.ipynb 39
def PCO2_calculation_from_mapping(
        mapping,
        category,
        aantal,
        **kwargs
):
    return mapping.get(category)(
        aantal=aantal,
        **kwargs
)

# %% ../../nbs/27_stal_massabalans.ipynb 50
def flatten_column_mapping(column_mapping: dict) -> list:
    '''Flatten the column mapping dictionary to a list of columns'''
    result = []
    for values in column_mapping.values():
        if isinstance(values, dict):
            result += flatten_column_mapping(values)
        elif isinstance(values, list):
            result += values
        else:
            result += [values]
    return result


# %% ../../nbs/27_stal_massabalans.ipynb 56
def find_production_column_names(data: DataFrame):
    '''Find the column names for the co2 production columns in the VERA data'''

    datacolumns = set(data.columns)
    columnnames = {
        'drachtdagen': [col for col in datacolumns if 'drachtdagen' in col.lower() or 'pregnancy' in col.lower()],
    }

    datacolumns = set(data.columns) - set(flatten_column_mapping(columnnames))
    columnnames.update({
        'energievoeding': [col for col in datacolumns if 'energy' in col.lower() or 'energie' in col.lower()],
    })
    
    datacolumns = set(data.columns) - set(flatten_column_mapping(columnnames))
    columnnames.update({
            'melkproductie': [
                col 
                for col in datacolumns 
                if ('milk production' in col.lower() and 'C3' not in col ) or 'melkproductie' in col.lower()
            ],
    })
    
    datacolumns = set(data.columns) - set(flatten_column_mapping(columnnames))
    columnnames.update({
            'gewichtstoename': [
                col 
                for col in datacolumns 
                if 'weight gain' in col.lower() or 'gewichtstoename' in col.lower()
            ]
    })

    datacolumns = set(data.columns) - set(flatten_column_mapping(columnnames))
    columnnames.update({
            'gewicht': [col for col in datacolumns if 'weight' in col.lower() or 'gewicht' in col.lower()],
    })

    datacolumns = set(data.columns) - set(flatten_column_mapping(columnnames))
    columnnames.update({
            'remaining_columns': list(datacolumns),
    })

    return  columnnames

# %% ../../nbs/27_stal_massabalans.ipynb 59
def extract_production_column_names(
    data: DataFrame # DataFrame with measurement data
) -> dict:
    
    '''Extract column names for the co2 production columns from the DataFrame'''

    columnnames = find_production_column_names(data)  

    def is_heifer(colname):
        return 'heifer' in colname.lower() or 'jongvee' in colname.lower() or 'pinken' in colname.lower()
    def is_cow(colname):
        return 'cow' in colname.lower() or 'koeien' in colname.lower() or 'melkvee' in colname.lower()
    def is_dry(colname):
        return ('dry' in colname.lower() or 'droog' in colname.lower()) and 'milking' not in  colname.lower()
    def is_milking(colname):
        return ('milking' in colname.lower() or 'melk' in colname.lower() or 'melkvee' in colname.lower()) and 'dry' not in colname.lower()
    def is_not_pregnant(colname):
        return 'not pregnant' in colname.lower() or 'niet drachtig' in colname.lower() 
    def is_pregnant(colname):
        return ('pregnant' in colname.lower() or 'drachtig' in colname.lower() or 'pregnancy' in colname.lower()) and not is_not_pregnant(colname)

    categories = {
        'melkvee': {
            'gewicht' : [
                cn 
                for cn in columnnames['gewicht'] 
                if is_milking(cn) and not is_heifer(cn)
            ],
            'drachtdagen' : [
                cn 
                for cn in columnnames['drachtdagen'] 
                if is_pregnant(cn) and not is_heifer(cn) and not is_dry(cn)
            ],
            'melkproductie' : [
                cn 
                for cn in columnnames['melkproductie'] 
                
            ],
            'aantal' : [
                cn 
                for cn in columnnames['remaining_columns']
                if is_cow(cn) and is_milking(cn) and not is_heifer(cn) and not '%' in cn and not 'production' in cn
            ]
        },
        'droogstaande koeien': {
            'gewicht' : [
                cn 
                for cn in columnnames['gewicht'] 
                if is_dry(cn) and not is_heifer(cn)
            ],
            'drachtdagen' : [
                cn 
                for cn in columnnames['drachtdagen'] 
                if is_dry(cn) and not is_heifer(cn) and is_pregnant(cn)
            ],
            'aantal' : [
                cn 
                for cn in columnnames['remaining_columns']
                if is_cow(cn) and  is_dry(cn) and not '%' in cn and not 'production' in cn
            ]
        },
        'drachtig jongvee': {
            'gewicht' : [
                cn 
                for cn in columnnames['gewicht'] 
                if is_heifer(cn) and is_pregnant(cn)
            ],
            'drachtdagen' : [
                cn 
                for cn in columnnames['drachtdagen'] 
                if is_heifer(cn) and is_pregnant(cn)
            ],
            'energievoeding' : [
                cn 
                for cn in columnnames['energievoeding'] 
                if is_heifer(cn)
            ],
            'gewichtstoename' : [
                cn 
                for cn in columnnames['gewichtstoename'] 
                if is_heifer(cn)
            ],
            'aantal' : [
                cn 
                for cn in columnnames['remaining_columns']
                if is_heifer(cn) and is_pregnant(cn) and not '%' in cn and not 'production' in cn
            ]
        },
        'niet drachtig jongvee': {
            'gewicht' : [
                cn 
                for cn in columnnames['gewicht'] 
                if is_heifer(cn) and not is_pregnant(cn)
            ],
            'energievoeding' : [
                cn 
                for cn in columnnames['energievoeding'] 
                if is_heifer(cn)
            ],
            'gewichtstoename' : [
                cn 
                for cn in columnnames['gewichtstoename'] 
                if is_heifer(cn)
            ],
            'aantal' : [
                cn 
                for cn in columnnames['remaining_columns']
                if is_heifer(cn) and not is_pregnant(cn) and not '%' in cn and not 'production' in cn
            ]

        }
    }

    return categories

# %% ../../nbs/27_stal_massabalans.ipynb 64
def find_emission_column_names(data: DataFrame):
    '''Find column names for NH3, CO2 and temperature from the DataFrame'''

    columnnames = {
        'nh3': [col for col in data.columns if any(name in col.lower() for name in MOLECULAR_NAMES['nh3']+['nh3'])],
        'co2': [col for col in data.columns if any(name in col.lower() for name in MOLECULAR_NAMES['co2']+['co2'])],
        'temp': [col for col in data.columns if 'temperatu' in col.lower()],
        'rh': [col for col in data.columns if 'vochtigheid' in col.lower() or 'rh' in col.lower()],
        'wind': [col for col in data.columns if 'wind' in col.lower()]
    }

    return columnnames


# %% ../../nbs/27_stal_massabalans.ipynb 66
def extract_emission_column_names(
        data: DataFrame # DataFrame with measurement data
) -> dict:
    '''Extract column names for NH3, CO2 and temperature from the DataFrame'''

    columnnames = find_emission_column_names(data)

    locations = {
            'binnen': ['binnen', 'inside', 'stal'],
            'buiten': ['buiten', 'outside', 'outdoor']
        }
    
    columnmapping = {K:{} for K in locations.keys()}
    for location_key, location_items in locations.items():
        for measure, columns in columnnames.items():
            for location_name in location_items:

                columnmapping[location_key][measure] = columnmapping[location_key].get(measure,[]) + [col for col in columns if location_name in col.lower()]

    columnmapping['buiten']['wind'] = columnmapping['buiten'].get('wind', []) + columnnames.get('wind', [])
    
    return columnmapping

# %% ../../nbs/27_stal_massabalans.ipynb 73
def resample_data(
        data: DataFrame,    # DataFrame with measurement data
        interval: str,      # resampling interval (e.g. '10min' for 10 minutes )
        method: str         # resampling method (e.g. 'linear', 'cubic' )
    ) -> DataFrame:
    
    '''Resample data to a specified interval and interpolate missing values with the givien method'''

    return data.mask(data < 0).resample(interval).interpolate(method, limit=3).dropna(how='any')

# %% ../../nbs/27_stal_massabalans.ipynb 79
def calculate_pco2_production_from_data(
        data: DataFrame,
        pco2_parameters=default_pco2_parameters
) -> DataFrame:
    
    pco2_columns = extract_production_column_names(data)
    pco2_data = {}

    for category, params in pco2_category_functions_parameters.items():
        if category not in pco2_columns:
            continue

        call_parameters = {}
        for param in params.keys():
            if param not in pco2_columns[category] or len(pco2_columns[category][param]) == 0:
                call_parameters[param] = pco2_parameters[category].get(param, default_pco2_parameters[category].get(param, params[param].default))
                #print(f'Using default value {call_parameters[param]} for parameter {param} of category {category}')
                continue

            colname = pco2_columns[category][param][0]
            call_parameters[param] = data[colname]
            #print(f'Using column {colname} for parameter {param} of category {category}')

        #print(f'Call parameters for category {category}: {call_parameters}')
        pco2_data[f'PCO2_{category}'] = pco2_category_functions_mapping[category](**call_parameters)
    

        # dict(inspect.signature(PCO2_melkvee).parameters)

    return  pd.concat(pco2_data, axis=1)


# %% ../../nbs/27_stal_massabalans.ipynb 84
def calculate_emission_ratio(
        NH3_stal,        # NH3 concentration in the barn in mg/m3
        NH3_buiten,      # NH3 concentration outside in mg/m3
        CO2_stal,        # CO2 concentration in the barn in ppm
        CO2_buiten       # CO2 concentration outside in ppm
    ):
    '''Calculate the emission ratio '''
    nh3_diff = gas_density_from_sensor_measurment(
        NH3_stal - NH3_buiten, 
        molweight=MOLECULAR_MASS['nh3'])
    
    co2_diff = gas_density_from_sensor_measurment(
        CO2_stal - CO2_buiten, 
        molweight=MOLECULAR_MASS['co2'])
    
    return nh3_diff / co2_diff  # dimensionless ratio
    

# %% ../../nbs/27_stal_massabalans.ipynb 109
def calculate_emission(
        data: DataFrame,        # DataFrame with measurement data
        pco2_parameters: dict,  # parameters for the PCO2 calculation
        bezetting: dict,        # dictionary with the animal categories and their counts
        interpolate: dict=dict(interval='7min', method='linear' ), # resampling interval and method

    ):
    '''Calculate the emission using the ratio method'''

    if interpolate:
        data = resample_data(data, **interpolate)
        
    columnmapping = extract_emission_column_names(data)

    if not bezetting:
        pco2_calculated = calculate_pco2_production_from_data(data, pco2_parameters)

    else:
        # Bereken de CO2 productie -------------------------------------
        pco2_function_mapping = create_pco2_function_mapping_from_parameters(pco2_parameters)
        pco2_calculated = pd.concat(
            [
                pco2_function_mapping.get(category)(**params).rename(category)
                for category, params in bezetting.items()
            ], axis=1
        )

    temperatuur = data[columnmapping['binnen']['temp']].mean(axis=1)
    pco2_corrected = pd.concat(
        [
            calculate_temperatuur_correctie(temperatuur).rename('temperatuur_correctie') , 
            pco2_calculated.sum(axis=1).rename('PCO2_totaal')
        ], axis=1
    )
    pco2_corrected['PCO2_corrected'] = pco2_corrected['PCO2_totaal'] * pco2_corrected['temperatuur_correctie']

    nh3_binnen = data[columnmapping['binnen']['nh3']].mean(axis=1)
    nh3_buiten = data[columnmapping['buiten']['nh3']].min(axis=1)
    co2_binnen = data[columnmapping['binnen']['co2']].mean(axis=1)
    co2_buiten = data[columnmapping['buiten']['co2']].min(axis=1)

    ratio = calculate_emission_ratio(
        NH3_stal=nh3_binnen,
        NH3_buiten=nh3_buiten,
        CO2_stal=co2_binnen,
        CO2_buiten=co2_buiten
    ).rename('ratio')

    emission = pd.concat([ratio, pco2_corrected], axis=1)
    emission['emission'] = (emission['ratio'] * emission['PCO2_corrected']) * 24 * 365

    return pd.concat([emission, data], axis=1)    

