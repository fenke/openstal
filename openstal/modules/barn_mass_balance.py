# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/27_stal_massabalans.ipynb.

# %% auto 0
__all__ = ['default_pco2_parameters', 'gas_density', 'gas_density_from_sensor_measurment', 'PCO2_melkvee', 'PCO2_pinken',
           'PCO2_temperatuurcorrectie', 'create_pco2_function_mapping', 'PCO2_calculation',
           'find_production_column_names', 'extract_production_column_names', 'find_emission_column_names',
           'extract_emission_column_names', 'resample_data', 'calculate_emission_ratio', 'calculate_emission']

# %% ../../nbs/27_stal_massabalans.ipynb 3
import numpy as np
import pandas as pd
from scipy.constants import gas_constant

from pandas import DataFrame
from corebridge.aicorebridge import AICoreModule



# %% ../../nbs/27_stal_massabalans.ipynb 5
kelvin_zero = -273.15

# %% ../../nbs/27_stal_massabalans.ipynb 6
MOLECULAR_MASS = dict(
    co2=44.01,
    nh3=17.031,
    ch4=16.043
)

MOLECULAR_NAMES = { 
    k: ([v] if isinstance(v, str) else list(v)) + [k]
    for k, v in dict(
        co2=['carbon_dioxide', 'carbon dioxide', 'kooldioxide', 'co2'],
        nh3=['ammonia', 'nh3', 'ammoniak'],
        ch4=['methane', 'methaan', 'ch4']
    ).items() 
}


# %% ../../nbs/27_stal_massabalans.ipynb 12
def gas_density(
        P:float,        # pressure in Pascal
        T:float,        # temperature in Kelvin
        ppm:float,      # measured parts per million
        molweight:float # molecular weight in grams per mole
    ):
    '''Calculates mass density in grams per cubic metre
    P : pressure in Pa
    T : temperature in degrees Kelvin
    ppm : measured parts per million
    molweight: molecular weight in grams per mole'''

    return (ppm/1000000) * molweight * P / (gas_constant * T)


# %% ../../nbs/27_stal_massabalans.ipynb 16
def gas_density_from_sensor_measurment(
        ppm:float,          # measured parts per million
        molweight:float):   # molecular weight in grams per mole
    '''Calculates mass density in milligrams per cubic metre'''

    return round(0.0409 * ppm * molweight,3)


# %% ../../nbs/27_stal_massabalans.ipynb 19
# =(5.6*(B10^0.75)+22*B7+1.6*(10^-5)*(B14^3))*B3/1000

def PCO2_melkvee(
        aantal,             # number of animals
        melkproductie,      # milk production in kg per animal per day
        drachtdagen,        # days carrying (average)
        gewicht             # average weight of the animals in kg 
    ):
    '''CO2 productie van melkvee per dier per dag
    gewicht: (gemiddelde) gewicht van de dieren
    melkproductie: melkproductie in kg per dier per dag
    drachtdagen: gemiddelde drachttijd (in dagen)
    De defaults zijn voor droogstaande koeien'''
    return aantal * 0.2 * (
        5.6 * np.pow(gewicht, 0.75) +
        22 * melkproductie +
        1.6e-5 * np.pow(drachtdagen, 3.0)
    ) / 1000.0


# %% ../../nbs/27_stal_massabalans.ipynb 23
def PCO2_pinken(
        aantal,             # number of animals
        energievoeding,     # energy feed
        drachtdagen,        # days carrying (average)
        gewicht,            # average weight of the animals in kg 
        gewichtstoename     # average weight gain of the animals in kg per day
    ):
        
    '''CO2 productie van pinken'''
    
    return aantal * 0.2 * (
        7.64 * np.pow(gewicht, 0.69) +
        gewichtstoename * 
            (23.0 / energievoeding - 1.0) * (
                (57.27 + 0.302 * gewicht) / 
                (1 - 0.171 * gewichtstoename) 
            ) +
        1.6e-5 * np.pow(drachtdagen, 3.0)
    ) / 1000.0




# %% ../../nbs/27_stal_massabalans.ipynb 27
def PCO2_temperatuurcorrectie(
        pco2,           # calculated CO2 production in cubic meters per hour
        temperatuur     # temperature in the barn in degrees Celsius
    ):
    '''Bereken temperatuur correctie voor de CO2 productie'''
    
    return pco2 * (1000.0 + 4.0 * (20.0 - temperatuur)) / 1000.0


# %% ../../nbs/27_stal_massabalans.ipynb 29
_default_parameters = [
    dict(
        categorie='melkvee',
        gewicht=650,  # kg
        drachtdagen=160,  # days
    ),
    dict(
        categorie='droogstaande koeien',
        gewicht=650,  # kg
        drachtdagen=220,  # days
    ),
    dict(
        categorie='drachtig jongvee',
        gewicht=400,  # kg
        drachtdagen=140,  # days
        energievoeding=10.0,  # MJ NEL per kg
        gewichtstoename=0.6,  # kg per day
    ),
    dict(
        categorie='niet drachtig jongvee',
        gewicht=250,  # kg
        drachtdagen=0,  # days
        energievoeding=10.0,  # MJ NEL per kg
        gewichtstoename=0.6,  # kg per day
    ),
]

# %% ../../nbs/27_stal_massabalans.ipynb 31
default_pco2_parameters = {
    kwargs_item.pop('categorie'): kwargs_item.copy()
    for kwargs_item in _default_parameters
}


# %% ../../nbs/27_stal_massabalans.ipynb 33
def create_pco2_function_mapping(pco2_parameters):
    '''Create a mapping of category to PCO2 calculation functions'''

    parameters = default_pco2_parameters.copy()
    parameters.update(pco2_parameters)
    #print(json.dumps(parameters, indent=4))

    return {
        'melkvee': lambda aantal, **kwargs: PCO2_melkvee(
            aantal=aantal,
            melkproductie=kwargs.get('melkproductie', parameters['melkvee']['melkproductie']),  # kg per day
            drachtdagen=kwargs.get('drachtdagen', parameters['melkvee']['drachtdagen']),  # days
            gewicht=kwargs.get('gewicht',  parameters['melkvee']['gewicht'])  # kg
        ),
        'droogstaande koeien': lambda aantal, **kwargs: PCO2_melkvee(
            aantal=aantal,
            melkproductie=kwargs.get('melkproductie', 0),  # kg per day
            drachtdagen=kwargs.get('drachtdagen', parameters['droogstaande koeien']['drachtdagen']),  # days
            gewicht=kwargs.get('gewicht', parameters['droogstaande koeien']['gewicht'])  # kg
        ),
        'drachtig jongvee': lambda aantal, **kwargs: PCO2_pinken(
            aantal=aantal,
            energievoeding=kwargs.get('energievoeding', parameters['drachtig jongvee']['energievoeding']),  # MJ NEL per kg
            drachtdagen=kwargs.get('drachtdagen', parameters['drachtig jongvee']['drachtdagen']),  # days
            gewicht=kwargs.get('gewicht', parameters['drachtig jongvee']['gewicht']),  # kg
            gewichtstoename=kwargs.get('gewichtstoename', parameters['drachtig jongvee']['gewichtstoename'])  # kg per day
        ),
        'niet drachtig jongvee': lambda aantal, **kwargs: PCO2_pinken(
            aantal=aantal,
            energievoeding=kwargs.get('energievoeding', parameters['niet drachtig jongvee']['energievoeding']),  # MJ NEL per kg
            drachtdagen=kwargs.get('drachtdagen', parameters['niet drachtig jongvee']['drachtdagen']),  # days
            gewicht=kwargs.get('gewicht', parameters['niet drachtig jongvee']['gewicht']),  # kg
            gewichtstoename=kwargs.get('gewichtstoename', parameters['niet drachtig jongvee']['gewichtstoename'])  # kg per day
        )
    }

# %% ../../nbs/27_stal_massabalans.ipynb 34
def PCO2_calculation(
        mapping,
        category,
        aantal,
        **kwargs
):
    return mapping.get(category)(
        aantal=aantal,
        **kwargs
)

# %% ../../nbs/27_stal_massabalans.ipynb 45
def flatten_column_mapping(column_mapping: dict) -> list:
    '''Flatten the column mapping dictionary to a list of columns'''
    result = []
    for values in column_mapping.values():
        if isinstance(values, dict):
            result += flatten_column_mapping(values)
        elif isinstance(values, list):
            result += values
        else:
            result += [values]
    return result


# %% ../../nbs/27_stal_massabalans.ipynb 52
def find_production_column_names(data: DataFrame):
    '''Find the column names for the co2 production columns in the VERA data'''

    datacolumns = set(data.columns)
    columnnames = {
        'drachtdagen': [col for col in datacolumns if 'drachtdagen' in col.lower() or 'pregnancy' in col.lower()],
    }

    datacolumns = set(data.columns) - set(flatten_column_mapping(columnnames))
    columnnames.update({
        'energievoeding': [col for col in datacolumns if 'energy' in col.lower() or 'energie' in col.lower()],
    })
    
    datacolumns = set(data.columns) - set(flatten_column_mapping(columnnames))
    columnnames.update({
            'melkproductie': [
                col 
                for col in datacolumns 
                if ('milk production' in col.lower() and not 'C3' in col ) or 'melkproductie' in col.lower()
            ],
    })
    
    datacolumns = set(data.columns) - set(flatten_column_mapping(columnnames))
    columnnames.update({
            'gewichtstoename': [
                col 
                for col in datacolumns 
                if 'weight gain' in col.lower() or 'gewichtstoename' in col.lower()
            ]
    })

    datacolumns = set(data.columns) - set(flatten_column_mapping(columnnames))

    columnnames.update({
            'gewicht': [col for col in datacolumns if 'weight' in col.lower() or 'gewicht' in col.lower()],
    })

    return  columnnames

# %% ../../nbs/27_stal_massabalans.ipynb 55
def extract_production_column_names(
    data: DataFrame # DataFrame with measurement data
) -> dict:
    
    '''Extract column names for the co2 production columns from the DataFrame'''

    columnnames = find_production_column_names(data)  

    def is_heifer(colname):
        return 'heifer' in colname.lower() or 'jongvee' in colname.lower() or 'pinken' in colname.lower()
    def is_cow(colname):
        return 'cow' in colname.lower() or 'koeien' in colname.lower() or 'melkvee' in colname.lower()
    def is_dry(colname):
        return 'dry' in colname.lower() or 'droog' in colname.lower()
    def is_milking(colname):
        return 'milking' in colname.lower() or 'melk' in colname.lower() or 'melkvee' in colname.lower()  
    def is_pregnant(colname):
        return 'pregnant' in colname.lower() or 'drachtig' in colname.lower() or 'pregnancy' in colname.lower()

    categories = {
        'melkvee': {
            'gewicht' : [
                cn 
                for cn in columnnames['gewicht'] 
                if is_milking(cn) and not is_heifer(cn)
            ],
            'drachtdagen' : [
                cn 
                for cn in columnnames['drachtdagen'] 
                if is_pregnant(cn) and not is_heifer(cn) and not is_dry(cn)
            ],
        },
        'droogstaande koeien': {
            'gewicht' : [
                cn 
                for cn in columnnames['gewicht'] 
                if is_dry(cn) and not is_heifer(cn)
            ],
            'drachtdagen' : [
                cn 
                for cn in columnnames['drachtdagen'] 
                if is_dry(cn) and not is_heifer(cn) and is_pregnant(cn)
            ],
        },
        'drachtig jongvee': {
            'gewicht' : [
                cn 
                for cn in columnnames['gewicht'] 
                if is_heifer(cn) and is_pregnant(cn)
            ],
            'drachtdagen' : [
                cn 
                for cn in columnnames['drachtdagen'] 
                if is_heifer(cn) and is_pregnant(cn)
            ],
            'energievoeding' : [
                cn 
                for cn in columnnames['energievoeding'] 
                if is_heifer(cn)
            ],
            'gewichtstoename' : [
                cn 
                for cn in columnnames['gewichtstoename'] 
                if is_heifer(cn)
            ]
        },
        'niet drachtig jongvee': {
            'gewicht' : [
                cn 
                for cn in columnnames['gewicht'] 
                if is_heifer(cn) and not is_pregnant(cn)
            ],
            'energievoeding' : [
                cn 
                for cn in columnnames['energievoeding'] 
                if is_heifer(cn)
            ],
            'gewichtstoename' : [
                cn 
                for cn in columnnames['gewichtstoename'] 
                if is_heifer(cn)
            ]

        }
    }

    return categories

# %% ../../nbs/27_stal_massabalans.ipynb 58
def find_emission_column_names(data: DataFrame):
    '''Find column names for NH3, CO2 and temperature from the DataFrame'''

    columnnames = {
        'nh3': [col for col in data.columns if any(name in col.lower() for name in MOLECULAR_NAMES['nh3']+['nh3'])],
        'co2': [col for col in data.columns if any(name in col.lower() for name in MOLECULAR_NAMES['co2']+['co2'])],
        'temp': [col for col in data.columns if 'temperatu' in col.lower()],
        'rh': [col for col in data.columns if 'vochtigheid' in col.lower() or 'rh' in col.lower()],
        'wind': [col for col in data.columns if 'wind' in col.lower()]
    }

    return columnnames


# %% ../../nbs/27_stal_massabalans.ipynb 60
def extract_emission_column_names(
        data: DataFrame # DataFrame with measurement data
) -> dict:
    '''Extract column names for NH3, CO2 and temperature from the DataFrame'''

    columnnames = find_emission_column_names(data)

    locations = {
            'binnen': ['binnen', 'inside', 'stal'],
            'buiten': ['buiten', 'outside', 'outdoor']
        }
    
    columnmapping = {K:{} for K in locations.keys()}
    for location_key, location_items in locations.items():
        for measure, columns in columnnames.items():
            for location_name in location_items:

                columnmapping[location_key][measure] = columnmapping[location_key].get(measure,[]) + [col for col in columns if location_name in col.lower()]

    columnmapping['buiten']['wind'] = columnmapping['buiten'].get('wind', []) + columnnames.get('wind', [])
    
    return columnmapping

# %% ../../nbs/27_stal_massabalans.ipynb 67
def resample_data(
        data: DataFrame,    # DataFrame with measurement data
        interval: str,      # resampling interval (e.g. '10min' for 10 minutes )
        method: str         # resampling method (e.g. 'linear', 'cubic' )
    ) -> DataFrame:
    
    '''Resample data to a specified interval and interpolate missing values with the givien method'''

    return data.mask(data < 0).resample(interval).interpolate(method, limit=3).dropna(how='any')

# %% ../../nbs/27_stal_massabalans.ipynb 71
def calculate_emission_ratio(
        NH3_stal,        # NH3 concentration in the barn in mg/m3
        NH3_buiten,      # NH3 concentration outside in mg/m3
        CO2_stal,        # CO2 concentration in the barn in ppm
        CO2_buiten       # CO2 concentration outside in ppm
    ):
    '''Calculate the emission ratio '''
    nh3_diff = gas_density_from_sensor_measurment(
        NH3_stal - NH3_buiten, 
        molweight=MOLECULAR_MASS['nh3'])
    
    co2_diff = gas_density_from_sensor_measurment(
        CO2_stal - CO2_buiten, 
        molweight=MOLECULAR_MASS['co2'])
    
    return nh3_diff / co2_diff  # dimensionless ratio
    

# %% ../../nbs/27_stal_massabalans.ipynb 74
def calculate_emission(
        data: DataFrame,        # DataFrame with measurement data
        pco2_parameters: dict,  # parameters for the PCO2 calculation
        bezetting: dict,        # dictionary with the animal categories and their counts
        interpolate: dict=dict(interval='7min', method='linear' ), # resampling interval and method

    ):
    '''Calculate the emission using the ratio method'''

    data = resample_data(data, **interpolate)
    columnmapping = extract_column_names(data)


    # Bereken de CO2 productie -------------------------------------
    temperatuur = data[columnmapping['stal']['temp']].mean(axis=1)
    pco2_mapping = create_pco2_function_mapping(pco2_parameters)
    pco2_calculated = pd.concat(
        [
            PCO2_temperatuurcorrectie(
                pco2_mapping.get(category)(**params),
                temperatuur
            ).rename(category)
            for category, params in bezetting.items()
        ], axis=1
    )
    pco2 = pco2_calculated.sum(axis=1) #----------------------------

    nh3_binnen = data[columnmapping['stal']['nh3']].mean(axis=1)
    nh3_buiten = data[columnmapping['buiten']['nh3']].min(axis=1)
    co2_binnen = data[columnmapping['stal']['co2']].mean(axis=1)
    co2_buiten = data[columnmapping['buiten']['co2']].min(axis=1)

    ratio = calculate_emission_ratio(
        NH3_stal=nh3_binnen,
        NH3_buiten=nh3_buiten,
        CO2_stal=co2_binnen,
        CO2_buiten=co2_buiten
    )


    emissie = ratio * pco2   # g NH3 per uur

    return emissie    

